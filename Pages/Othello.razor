@page "/"


<h1>(Ot)Hello</h1>
<h1>X har @wins[0] sejre. O har @wins[1] sejre.</h1>
<h2>X har @points[0] point. O har @points[1] point.</h2>

<button @onclick="startup">Start spillet forfra</button>

<br>
<h3>@errorMessage <br></h3>
<h2>Det er @turn 's tur</h2>

<table class="table" style="width:200px; table-layout:fixed; text-align:center;">
  @for(int i=0; i<8; i++)
  {
    int IValue = i;
    <tr>
    @for(int j=0; j<8; j++)
    {
      int JValue = j;
      <td style="heigh:200px; border:1px solid black; border-collapse:collapse;" @onclick="(() => load(IValue, JValue) )">
        @bræt[i, j]
      </td>
    }
    </tr>
  }
</table>

<br>
<br>
<br>

<p>det nyeste træk</p>
<table class="table" style="width:200px; table-layout:fixed; text-align:center;">
  @for(int i=0; i<8; i++)
  {
    int IValue = i;
    <tr>
    @for(int j=0; j<8; j++)
    {
      int JValue = j;
      <td style="heigh:200px; border:1px solid black; border-collapse:collapse;">
        @nysttræk[i, j]
      </td>

    }
    </tr>
  }
</table>

<br>

<p>det andet nyeste træk</p>
<table class="table" style="width:200px; table-layout:fixed; text-align:center;">
  @for(int i=0; i<8; i++)
  {
    int IValue = i;
    <tr>
    @for(int j=0; j<8; j++)
    {
      int JValue = j;
      <td style="heigh:200px; border:1px solid black; border-collapse:collapse;">
        @andttræk[i, j]
      </td>

    }
    </tr>
  }
</table>

<br>

<p>det tredje nyeste træk</p>
<table class="table" style="width:200px; table-layout:fixed; text-align:center;">
  @for(int i=0; i<8; i++)
  {
    int IValue = i;
    <tr>
    @for(int j=0; j<8; j++)
    {
      int JValue = j;
      <td style="heigh:200px; border:1px solid black; border-collapse:collapse;">
        @tredjtræk[i, j]
      </td>

    }
    </tr>
  }
</table>

@code
{
/*  protected override async Task OnInitializedAsync()
  {

  }
*/

  // brættet
  public string[,] bræt = {
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "X", "-", "-", "-", "-"},
    {"-", "-", "X", "o", "x", "-", "-", "-"},
    {"-", "-", "-", "x", "o", "X", "-", "-"},
    {"-", "-", "-", "-", "X", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"}
  };

  // den besked der bliver returned, hver gang der er lavet et træk
  public string errorMessage="";

  // den input man får af brugeren.
  public string[]? strCords = new string[2];

  // int versionen af koordinaterne (kaldes en tuple)
  public (int x, int y) intCords;

  // hvis tur det er. Kan enten være 'x' eller 'o'
  public string turn = "x";

  // metode der bliver kaldt når spillet skal startes forfra 
  public void startup()
  {
    bræt = new string[8,8] {
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "o", "x", "-", "-", "-"},
    {"-", "-", "-", "x", "o", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"}
  };

  nysttræk = new string[8,8] {
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"}
  };

  andttræk = new string[8,8] {
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"}
  };

  tredjtræk = new string[8,8] {
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"}
  };

  turn = "x";
    availableSpots(bræt, turn);
    points = new int[] {2,2};
    return;
  }

  // metode der bliver kaldt, hver gang der sker et træt
  public void load(int xCord, int yCord)
  {
    intCords = (xCord, yCord);

    // opdater brættet 
    errorMessage = updateBoard(bræt, intCords, turn);

    // hvis der ikke er nogen fejlbeskeder
    if (errorMessage == "") 
    {
      if (turn=="x")
      {
        turn = "o";
      }
      else 
      {
        turn = "x";
      }

      // sørger for alle ledige pladser bliver vist
      availableSpots(bræt, turn);

      // opdaterer scoren
      countPoints();

      // hvis man ikke kan gøre noget, får den anden person turen
      if (!canMove) {
        if (turn=="x")
        {
          turn = "o";
        }

        else 
        {
          turn = "x";
        }

        // vi prøver nu igen at vise hvilke nogen man kan klikke på
        availableSpots(bræt, turn);      

        // hvis den anden person heller ikke kan gøre noget, starter vi altså bare forfra
        if (!canMove){
          // dem der har flest point vinder
          if (points[0]<points[1]){
            wins[1]++;
          } else if (points[0]>points[1]){
            wins[0]++;
          } // else: draw
          startup();
        }
      }
    } 
  }
  
  // point som hver spiller har. Hold
  public int[] wins = {0,0};
  public int[] points = {2, 2};

  // metode der giver point til dem der har vundet.
  public void countPoints(){
    points[0] = 0;
    points[1] = 0;

    // for hver position i brættet ser vi om det er x eller o og tæller.
    foreach(string position in bræt){
      if (position == "x"){
        points[0]++;
      }
      else if (position == "o"){
        points[1]++;
      }
    }
    return;
  }

  public string possiblePos(string color) {
    if(color=="x") {
      return("X");
    } else if(color=="o"){
      return("O");
    }
    else {
      return ("gg");
    }
  }

  public bool canMove = true;
  // metode, der bestemmer alle pladser, hvor man kan lægge sin brik. Den 'farver' også alle de steder, hvor man kan lægge sin brik.
  public void availableSpots(string[,] board, string color) 
  {
    // workaround lol
    string nColor = "";
    if(color=="x"){
      nColor = "o";
    } else {
      nColor = "x";
    }

    // som udgangspunkt er der ikke nogle mulige træk:
    canMove = false;


    (int x, int y) pos;
    // tjekker bare for alle pladser: hvis der bliver vendt en brik når man lægger der, er det en mulig placering.
    for (int row=0; row<8; row++){

      for (int column=0; column<8; column++){

        pos.x = row;
        pos.y = column;

        // hvis der bliver vendt nogle brikker, når man ligger sin brik her.
        if (turningDisks(board, pos, color).Count != 0) {

          // hvis brikken endda også er tom
          if (board[row, column] == "-" || board[row, column] == possiblePos(nColor)){
            board[row, column] = possiblePos(color);

            // hvis der er (mindst et M) på brættet, kan man altså godt placere en brik
            canMove = true;
          }

        // hvis man ikke kan ligge en brik, men brikken er markeret, skal vi lige fjerne markeringen
        } else if (board[row, column] == possiblePos(nColor)) {
          board[row, column] = "-";
        }
      }
    }
    return;
  }

  // funktionen får givet (x,y) koordinater til den brik der bliver lagt samt farven af den brik.
  // Den bestemmer derefter hvilke brikker der skal vendes og returnerer koordinaterne af disse brikker
  // som en liste af (x,y)-koordinater. 
  public List<(int x, int y)> turningDisks(string[,] board, (int x, int y) diskPos, string color)
  {
    // workaround igen
    string nColor = "";
    if(color=="x"){
      nColor = "o";
    } else {
      nColor = "x";
    }

    // laver en liste som er den liste der skal returneres.
    List<(int x, int y)> ret = new List<(int x, int y)>();

    // vi vil tjekke alle retninger, 
    int [,] directions = {{0,1}, {1,1}, {1,0}, {1,-1}, {0,-1}, {-1,-1}, {-1,0}, {-1,1}};

    // toBeMarked er listen med koordinater af alle ting der skal vendes til en ny farve
    // tempToBeMarked er alle dem, der 'måske' skal vendes.
    List<(int, int)> toBeMarked = new List<(int x, int y)>();
    List<(int, int)> tempToBeMarked = new List<(int x, int y)>();
    
    int dir1;
    int dir2;

    int[] checkedCords = new int[2];
    

    // kører følgende kode i hver retning
    for (int i=0; i<8; i++) 
    {
      tempToBeMarked = new List<(int x, int y)>();
      dir1 = directions[i, 0];
      dir2 = directions[i, 1];

      int j = 0; // index for hvor langt ud vi går 
      while (true) 
      {
        j++;
        // hvis vi er ude af brættet
        if ( !(0<=diskPos.x+j*dir1 && diskPos.x+j*dir1<=7 && 0<=diskPos.y+j*dir2 && diskPos.y+j*dir2<=7) ) 
        {
          break;
        }

        // hvis systemet tjekker en ensfarvet
        if (board[diskPos.x+j*dir1, diskPos.y+j*dir2] == color) 
        {
          // tilføjer lige alle de diske der skal vendes.
          foreach ((int, int) disk in tempToBeMarked) 
          {
              toBeMarked.Add((disk.Item1, disk.Item2));
          }
          break;
        }

        // hvis systemet tjekker en tom
        else if (board[diskPos.x+j*dir1, diskPos.y+j*dir2] == "-" || board[diskPos.x+j*dir1, diskPos.y+j*dir2] == possiblePos(nColor) || board[diskPos.x+j*dir1, diskPos.y+j*dir2] == possiblePos(color)) 
        {
          break;
        }

        // hvis det er modstanderens brik
        else 
        {
          tempToBeMarked.Add((diskPos.x+j*dir1, diskPos.y+j*dir2));
        }

      }
    }
    return toBeMarked;
  }

  public (int x, int y) checkingCords;
  // note. åbentbart når vi ændrer på 'ret' ændrer vi direkte på 'board' og dermed 'bræt'
  // vi ændrer altså på selve listen fordi den refererer til stedet i hukkomelsen hvor listen ligger, frem for at lave en duplicate
  // derfor returnerer vi et tal (0) hvis programmet er succes, (1), hvis der ikke bliver ændret på nogle brikker.
  public string updateBoard(string[,] board, (int x, int y) diskPos, string color) //board er 8x8, og diskPos er (y,x). Y målt oppefra og ned
  {
    // definerer brættet som udgangspunkt
    string[,] ret = board;

    //// fejlbeskeder

    // hvis brikken ikke kan ligge på brættet. Denne skal være før den næste fejlbesked
    if (!(0<=diskPos.x && diskPos.x<=7 && 0<=diskPos.y && diskPos.y<=7))
    {
      return ("Der er valgt en placering der ligger uden for brættet.");
    }

    // hvis det er et ugyldigt felt uden en brik
    else if (ret[diskPos.x, diskPos.y] == "-")
    {
      return ("Du må ikke lægge din brik der. Der er nemlig ingen brikker der bliver vendt.");
    }

    // hvis der allerede er en brik på den plads
    else if (ret[diskPos.x, diskPos.y] != possiblePos(color)){
      return ("Du må ikke lægge der, denne placering er allerede optaget");
    }

    // opdater bræthistorikken 
   //opdatny()
    
    // vi sætter toBeMarked til at være alle de brikker som skal vendes.
    List<(int x, int y)> toBeMarked = new List<(int x, int y)>();
    toBeMarked = turningDisks(board, diskPos, color);

    // vi vender alle de disks som skal vendes. 
    foreach ((int x, int y) pos in toBeMarked)
    {
      ret[pos.x, pos.y] = color;
    }

    // opdaterer brættet med det nye bræt
    ret[diskPos.x, diskPos.y]=color;

    // returnerer
    return ("");
  }

  //historik for de sidste tre træk:
public string[,] nysttræk = {
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"}
};

public string[,] andttræk = {
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"}
};

public string[,] tredjtræk = {
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"}
};

//metoder til at opdatere historik

 public void opdatny(int x, int y)
    {
        for (int i = 0; i >= 8; i++)
        {
            for (int j = 0; j <= 8; j++)
            {
                nysttræk[i,j] = bræt[i,j];
            }
        }
    }


}