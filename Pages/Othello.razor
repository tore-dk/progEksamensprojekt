@page "/"
<h1>(Ot)Hello</h1>
<h1>X har @wins[0] sejre. O har @wins[1] sejre.</h1>
<h2>X har @points[0] point. O har @points[1] point.</h2>

<input type="text" @bind=@strCords[0]>
<input type="text" @bind=@strCords[1]>

<button @onclick="load">Indsæt tal</button>
<button @onclick="startup">Start spillet forfra</button>

<br>
<h3>@errorMessage <br></h3>
<h2>Det er @turn 's tur</h2>

<table class="table" style="width:200px; table-layout:fixed;">
  @for(int i=0; i<8; i++)
  {
    <tr>
    @for(int j=0; j<8; j++)
    {
      <td style="heigh:200px;">
        @bræt[i, j]
      </td>

    }
    </tr>
  }
</table>

@code
{
/*  protected override async Task OnInitializedAsync()
  {

  }
*/

  // brættet
  public string[,] bræt = {
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "M", "-", "-", "-", "-"},
    {"-", "-", "M", "o", "x", "-", "-", "-"},
    {"-", "-", "-", "x", "o", "M", "-", "-"},
    {"-", "-", "-", "-", "M", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"}
  };

  // den besked der bliver returned, hver gang der er lavet et træk
  public string errorMessage="";

  // den input man får af brugeren.
  public string[]? strCords = new string[2];

  // int versionen af koordinaterne
  public (int x, int y) intCords;

  // hvis tur det er. Kan enten være 'x' eller 'o'
  public string turn = "x";

  // metode der bliver kaldt når spillet skal startes forfra 
  public void startup()
  {
    bræt = new string[8,8] {
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "o", "x", "-", "-", "-"},
    {"-", "-", "-", "x", "o", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"},
    {"-", "-", "-", "-", "-", "-", "-", "-"}
  };
    turn = "x";
    availableSpots(bræt, turn);
    return;
  }

  // metode der bliver kaldt, hver gang der sker et træt
  public void load()
  {
    intCords = (8-int.Parse(strCords[1]), int.Parse(strCords[0])-1);

    // opdater brættet 
    errorMessage = updateBoard(bræt, intCords, turn);

    // hvis der ikke er nogen fejlbeskeder
    if (errorMessage == "") 
    {
      if (turn=="x")
      {
        turn = "o";
      }
      else 
      {
        turn = "x";
      }

      // sørger for alle ledige pladser bliver vist
      availableSpots(bræt, turn);

      // opdaterer scoren
      countPoints();

      // hvis man ikke kan gøre noget, får den anden person turen
      if (!canMove) {
        if (turn=="x")
        {
          turn = "o";
        }

        else 
        {
          turn = "x";
        }

        // vi prøver nu igen at vise hvilke nogen man kan klikke på
        availableSpots(bræt, turn);      

        // hvis den anden person heller ikke kan gøre noget, starter vi altså bare forfra
        if (!canMove){
          // dem der har flest point vinder
          if (points[0]<points[1]){
            wins[1]++;
          } else if (points[0]>points[1]){
            wins[0]++;
          } // else: draw
          startup();
        }
      }



    } 
  }
  
  // point som hvert hold har. Hold
  public int[] wins = {0,0};
  public int[] points = {2, 2};

  // metode der giver point til dem der har vundet.
  public void countPoints(){
    points[0] = 0;
    points[1] = 0;

    // for hver position i brættet ser vi om det er x eller o og tæller.
    foreach(string position in bræt){
      if (position == "x"){
        points[0]++;
      }
      else if (position == "o"){
        points[1]++;
      }
    }
    return;
  }


  public bool canMove = true;
  // metode, der bestemmer alle pladser, hvor man kan ligge sin brik. Den 'farver' også alle de steder, hvor man kan ligge sin brik.
  public void availableSpots(string[,] board, string color) 
  {
    // som udgangspunkt er der ikke nogle mulige træk:
    canMove = false;


    (int x, int y) pos;
    // tjekker bare for alle pladser: hvis der bliver vendt en brik når man ligger der, er det et available spot.
    for (int row=0; row<8; row++){

      for (int column=0; column<8; column++){

        pos.x = row;
        pos.y = column;

        // hvis man godt må ligge sin brik (evt. oveni)
        if (turningDisks(board, pos, color).Count != 0) {

          // hvis brikken endda også er tom
          if (board[row, column] == "-" || board[row, column] == "M"){
            board[row, column] = "M";

            // hvis der er (mindst et M) på brættet, kan man altså godt placere en brik
            canMove = true;
          }

        // hvis man ikke kan ligge en brik, men brikken er markeret, skal vi lige fjerne markeringen
        } else if (board[row, column] == "M") {
          board[row, column] = "-";
        }
      }
    }
    return;
  }

  // deciding which disks to turn. Returns a list with the coordinates to the lists that should be turned.
  public List<(int x, int y)> turningDisks(string[,] board, (int x, int y) diskPos, string color)
  {
    // laver en liste som er den liste der skal returneres.
    List<(int x, int y)> ret = new List<(int x, int y)>();

    // vi vil tjekke alle retninger, 
    int [,] directions = {{0,1}, {1,1}, {1,0}, {1,-1}, {0,-1}, {-1,-1}, {-1,0}, {-1,1}};

    // toBeMarked er listen med koordinater af alle ting der skal vendes til en ny farve
    // tempToBeMarked er alle dem, der 'måske' skal vendes.
    List<(int, int)> toBeMarked = new List<(int x, int y)>();
    List<(int, int)> tempToBeMarked = new List<(int x, int y)>();
    
    int dir1;
    int dir2;

    int[] checkedCords = new int[2];
    

    // kører følgende kode i hver retning
    for (int i=0; i<8; i++) 
    {
      tempToBeMarked = new List<(int x, int y)>();
      dir1 = directions[i, 0];
      dir2 = directions[i, 1];

      int j = 0; // index for hvor langt ud vi går 
      while (true) 
      {
        j++;
        // hvis vi er ude af brættet
        if ( !(0<=diskPos.x+j*dir1 && diskPos.x+j*dir1<=7 && 0<=diskPos.y+j*dir2 && diskPos.y+j*dir2<=7) ) 
        {
          break;
        }

        // hvis systemet tjekker en ensfarvet
        if (board[diskPos.x+j*dir1, diskPos.y+j*dir2] == color) 
        {
          // tilføjer lige alle de diske der skal vendes.
          foreach ((int, int) disk in tempToBeMarked) 
          {
              toBeMarked.Add((disk.Item1, disk.Item2));
          }
          break;
        }

        // hvis sys tjekker en tom
        else if (board[diskPos.x+j*dir1, diskPos.y+j*dir2] == "-" || board[diskPos.x+j*dir1, diskPos.y+j*dir2] == "M") 
        {
          break;
        }

        // hvis det er modstanders brik
        else 
        {
          tempToBeMarked.Add((diskPos.x+j*dir1, diskPos.y+j*dir2));
        }

      }
    }
    return toBeMarked;
  }

  public (int x, int y) checkingCords;
  // note. åbentbart når man vi ændrer på 'ret' ændrer vi direkte på 'board' og dermed 'bræt'
  // vi ændrer altså på selve listen fordi den refererer til stedet i hukkomelsen hvor listen ligger, frem for at lave en duplicate
  // derfor returnerer vi et tal (0) hvis programmet er succes, (1), hvis der ikke bliver ændret på nogle brikker.
  public string updateBoard(string[,] board, (int x, int y) diskPos, string color) //board er 8x8, og diskPos er (y,x). Y målt oppefra og ned
  {
    // definerer brættet som udgangspunkt
    string[,] ret = board;

    //// fejlbeskeder

    // hvis brikken ikke kan ligge på brættet. Denne skal være før den næste fejlbesked
    if (!(0<=diskPos.x && diskPos.x<=7 && 0<=diskPos.y && diskPos.y<=7))
    {
      return ("Der er valgt en brik der ligger uden for brættet.");
    }

    // hvis der allerede er en brik på den plads
    if (ret[diskPos.x, diskPos.y] == "-")
    {
      return ("Du må ikke lægge din brik der. Der er nemlig ingen brikker der bliver vendt.");
    }

    if (ret[diskPos.x, diskPos.y] != "M"){
      return ("Du må ikke ligge der, denne brik er allerede opgavet");
    }

    
    // vi sætter toBeMarked til at være alle de disks som skal vendes.
    List<(int x, int y)> toBeMarked = new List<(int x, int y)>();
    toBeMarked = turningDisks(board, diskPos, color);

    // vi vender alle de disks som skal vendes. 
    foreach ((int x, int y) pos in toBeMarked)
    {
      ret[pos.x, pos.y] = color;
    }

    // opdaterer brættet med det nye bræt
    ret[diskPos.x, diskPos.y]=color;

    // returnerer
    return ("");


  }


}